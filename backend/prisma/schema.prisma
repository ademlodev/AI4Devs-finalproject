// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum VerificationLevel {
  UNVERIFIED
  EMAIL_VERIFIED
  PHONE_VERIFIED
  DOCUMENT_VERIFIED
  FULL_VERIFIED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  BANNED
}

enum ItemCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
  POOR
}

enum AvailabilityStatus {
  AVAILABLE
  RESERVED
  EXCHANGED
  UNAVAILABLE
}

enum MatchStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum ConversationStatus {
  ACTIVE
  PAUSED
  CLOSED
}

enum MessageType {
  TEXT
  IMAGE
  SYSTEM
  OFFER
}

enum TransactionStatus {
  PROPOSED
  ACCEPTED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum ReportType {
  SPAM
  INAPPROPRIATE_CONTENT
  FRAUD
  HARASSMENT
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum VerificationType {
  EMAIL
  PHONE
  DOCUMENT_ID
  ADDRESS
  SOCIAL_MEDIA
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum NotificationType {
  NEW_MATCH
  NEW_MESSAGE
  TRANSACTION_UPDATE
  RATING_RECEIVED
  SYSTEM_ALERT
}

// Models
model User {
  id                   String            @id @default(uuid())
  email                String            @unique
  passwordHash         String            @map("password_hash")
  firstName            String            @map("first_name")
  lastName             String            @map("last_name")
  phone                String?
  profileImageUrl      String?           @map("profile_image_url")
  bio                  String?
  locationCoordinates  Json?             @map("location_coordinates")
  address              String?
  averageRating        Float             @default(0.0) @map("average_rating")
  totalRatings         Int               @default(0) @map("total_ratings")
  verificationLevel    VerificationLevel @default(UNVERIFIED) @map("verification_level")
  status               UserStatus        @default(ACTIVE)
  createdAt            DateTime          @default(now()) @map("created_at")
  updatedAt            DateTime          @updatedAt @map("updated_at")

  // Relations
  items               Item[]
  userPreferences     UserPreference?
  userVerifications   UserVerification[]
  notifications       Notification[]
  reportsSubmitted    Report[]           @relation("ReporterReports")
  reportsReceived     Report[]           @relation("ReportedUserReports")
  ratingsGiven        Rating[]           @relation("RaterRatings")
  ratingsReceived     Rating[]           @relation("RatedUserRatings")
  messagesSent        Message[]
  matchesAsUserA      Match[]            @relation("UserAMatches")
  matchesAsUserB      Match[]            @relation("UserBMatches")
  conversationsAsUserA Conversation[]    @relation("UserAConversations")
  conversationsAsUserB Conversation[]    @relation("UserBConversations")
  transactionsAsUserA Transaction[]      @relation("UserATransactions")
  transactionsAsUserB Transaction[]      @relation("UserBTransactions")
  moderatedReports    Report[]           @relation("ModeratorReports")
  verifiedUsers       UserVerification[] @relation("VerifierVerifications")

  @@map("users")
}

model Category {
  id          String        @id @default(uuid())
  name        String
  description String?
  iconUrl     String?       @map("icon_url")
  sortOrder   Int           @default(0) @map("sort_order")
  isActive    Boolean       @default(true) @map("is_active")
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  // Relations
  subcategories Subcategory[]
  items         Item[]

  @@map("categories")
}

model Subcategory {
  id          String   @id @default(uuid())
  categoryId  String   @map("category_id")
  name        String
  description String?
  sortOrder   Int      @default(0) @map("sort_order")
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  items    Item[]

  @@map("subcategories")
}

model Item {
  id                  String             @id @default(uuid())
  userId              String             @map("user_id")
  categoryId          String             @map("category_id")
  subcategoryId       String?            @map("subcategory_id")
  title               String
  description         String
  images              Json?
  condition           ItemCondition
  availabilityStatus  AvailabilityStatus @default(AVAILABLE) @map("availability_status")
  locationCoordinates Json?              @map("location_coordinates")
  address             String?
  tags                Json?
  isActive            Boolean            @default(true) @map("is_active")
  createdAt           DateTime           @default(now()) @map("created_at")
  updatedAt           DateTime           @updatedAt @map("updated_at")

  // Relations
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  category     Category      @relation(fields: [categoryId], references: [id])
  subcategory  Subcategory?  @relation(fields: [subcategoryId], references: [id])
  matchesAsItemA Match[]     @relation("ItemAMatches")
  matchesAsItemB Match[]     @relation("ItemBMatches")
  transactionsAsItemA Transaction[] @relation("ItemATransactions")
  transactionsAsItemB Transaction[] @relation("ItemBTransactions")
  reports      Report[]

  @@map("items")
}

model Match {
  id                String      @id @default(uuid())
  userAId           String      @map("user_a_id")
  userBId           String      @map("user_b_id")
  itemAId           String      @map("item_a_id")
  itemBId           String      @map("item_b_id")
  compatibilityScore Float      @map("compatibility_score")
  status            MatchStatus @default(PENDING)
  algorithmData     Json?       @map("algorithm_data")
  createdAt         DateTime    @default(now()) @map("created_at")
  updatedAt         DateTime    @updatedAt @map("updated_at")

  // Relations
  userA        User           @relation("UserAMatches", fields: [userAId], references: [id], onDelete: Cascade)
  userB        User           @relation("UserBMatches", fields: [userBId], references: [id], onDelete: Cascade)
  itemA        Item           @relation("ItemAMatches", fields: [itemAId], references: [id], onDelete: Cascade)
  itemB        Item           @relation("ItemBMatches", fields: [itemBId], references: [id], onDelete: Cascade)
  conversation Conversation?
  transaction  Transaction?

  @@unique([userAId, userBId, itemAId, itemBId])
  @@map("matches")
}

model Conversation {
  id              String             @id @default(uuid())
  matchId         String             @unique @map("match_id")
  userAId         String             @map("user_a_id")
  userBId         String             @map("user_b_id")
  status          ConversationStatus @default(ACTIVE)
  lastMessageAt   DateTime?          @map("last_message_at")
  createdAt       DateTime           @default(now()) @map("created_at")
  updatedAt       DateTime           @updatedAt @map("updated_at")

  // Relations
  match    Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)
  userA    User        @relation("UserAConversations", fields: [userAId], references: [id], onDelete: Cascade)
  userB    User        @relation("UserBConversations", fields: [userBId], references: [id], onDelete: Cascade)
  messages Message[]
  transaction Transaction?

  @@map("conversations")
}

model Message {
  id             String      @id @default(uuid())
  conversationId String      @map("conversation_id")
  senderId       String      @map("sender_id")
  content        String
  messageType    MessageType @default(TEXT) @map("message_type")
  metadata       Json?
  isRead         Boolean     @default(false) @map("is_read")
  createdAt      DateTime    @default(now()) @map("created_at")

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reports      Report[]

  @@map("messages")
}

model Transaction {
  id               String            @id @default(uuid())
  matchId          String            @unique @map("match_id")
  conversationId   String            @unique @map("conversation_id")
  userAId          String            @map("user_a_id")
  userBId          String            @map("user_b_id")
  itemAId          String            @map("item_a_id")
  itemBId          String            @map("item_b_id")
  status           TransactionStatus @default(PROPOSED)
  exchangeDetails  Json?             @map("exchange_details")
  agreedAt         DateTime?         @map("agreed_at")
  completedAt      DateTime?         @map("completed_at")
  createdAt        DateTime          @default(now()) @map("created_at")
  updatedAt        DateTime          @updatedAt @map("updated_at")

  // Relations
  match        Match        @relation(fields: [matchId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userA        User         @relation("UserATransactions", fields: [userAId], references: [id], onDelete: Cascade)
  userB        User         @relation("UserBTransactions", fields: [userBId], references: [id], onDelete: Cascade)
  itemA        Item         @relation("ItemATransactions", fields: [itemAId], references: [id], onDelete: Cascade)
  itemB        Item         @relation("ItemBTransactions", fields: [itemBId], references: [id], onDelete: Cascade)
  ratings      Rating[]

  @@map("transactions")
}

model Rating {
  id            String   @id @default(uuid())
  transactionId String   @map("transaction_id")
  raterId       String   @map("rater_id")
  ratedId       String   @map("rated_id")
  score         Int      @db.SmallInt
  comment       String?
  tags          Json?
  isModerated   Boolean  @default(false) @map("is_moderated")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  rater       User        @relation("RaterRatings", fields: [raterId], references: [id], onDelete: Cascade)
  rated       User        @relation("RatedUserRatings", fields: [ratedId], references: [id], onDelete: Cascade)

  @@unique([transactionId, raterId, ratedId])
  @@map("ratings")
}

model UserPreference {
  id                   String   @id @default(uuid())
  userId               String   @unique @map("user_id")
  interests            Json?
  categories           Json?
  maxDistanceKm        Float?   @map("max_distance_km")
  notificationSettings Json?    @map("notification_settings")
  privacySettings      Json?    @map("privacy_settings")
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model Report {
  id               String       @id @default(uuid())
  reporterId       String       @map("reporter_id")
  reportedUserId   String?      @map("reported_user_id")
  reportedItemId   String?      @map("reported_item_id")
  reportedMessageId String?     @map("reported_message_id")
  reportType       ReportType   @map("report_type")
  description      String
  status           ReportStatus @default(PENDING)
  moderatorId      String?      @map("moderator_id")
  moderatorNotes   String?      @map("moderator_notes")
  resolvedAt       DateTime?    @map("resolved_at")
  createdAt        DateTime     @default(now()) @map("created_at")
  updatedAt        DateTime     @updatedAt @map("updated_at")

  // Relations
  reporter       User     @relation("ReporterReports", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedUser   User?    @relation("ReportedUserReports", fields: [reportedUserId], references: [id], onDelete: SetNull)
  reportedItem   Item?    @relation(fields: [reportedItemId], references: [id], onDelete: SetNull)
  reportedMessage Message? @relation(fields: [reportedMessageId], references: [id], onDelete: SetNull)
  moderator      User?    @relation("ModeratorReports", fields: [moderatorId], references: [id], onDelete: SetNull)

  @@map("reports")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  content   String
  data      Json?
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model UserVerification {
  id                 String             @id @default(uuid())
  userId             String             @map("user_id")
  verificationType   VerificationType   @map("verification_type")
  verificationData   String             @map("verification_data")
  status             VerificationStatus @default(PENDING)
  verifiedById       String?            @map("verified_by_id")
  verifiedAt         DateTime?          @map("verified_at")
  expiresAt          DateTime?          @map("expires_at")
  createdAt          DateTime           @default(now()) @map("created_at")
  updatedAt          DateTime           @updatedAt @map("updated_at")

  // Relations
  user       User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  verifiedBy User? @relation("VerifierVerifications", fields: [verifiedById], references: [id], onDelete: SetNull)

  @@unique([userId, verificationType])
  @@map("user_verifications")
}